{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/aeft/utils.ts","../../../src/jsx/aeft/subAnimations.ts","../../../src/jsx/aeft/easeValues.ts","../../../src/jsx/aeft/animate.ts","../../../src/jsx/aeft/aeft-utils.ts","../../../src/jsx/aeft/aeft.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.toona.nigiri\",\n  displayName: \"Nigiri\",\n  symlink: \"local\",\n  port: 3005,\n  servePort: 5000,\n  startingDebugPort: 8860,\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [{ name: \"AEFT\", version: \"[0.0,99.9]\" }],\n  type: \"Panel\",\n  iconDarkNormal: \"./src/assets/light-icon.png\",\n  iconNormal: \"./src/assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 500,\n  height: 550,\n\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"Nigiri\",\n      autoVisible: true,\n      width: 600,\n      height: 650,\n    },\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"CA\",\n    org: \"MyCompany\",\n    password: \"mypassword\",\n    tsa: \"http://timestamp.digicert.com/\",\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [],\n  copyAssets: [],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\r\nexport const ns = config.id;\r\n","export type LayerObj = {\n  name: string;\n  index: number;\n  layer: AVLayer;\n  count: number;\n  scaleFactor: number;\n  pan: boolean;\n  in: string;\n  out: string;\n  prev: string;\n  darken: boolean;\n  padding: number;\n};\n\nexport const getLayers = (\n  comp: CompItem,\n  layerArray: any[],\n  parentFold: FolderItem\n): LayerObj[] => {\n  let layers = [];\n  let newComp = app.project.items.addComp(\"internal\", 1080, 1920, 1, 15, 24);\n  newComp.parentFolder = parentFold;\n  for (let i = 1; i <= comp.numLayers; i++) {\n    let currLayer = comp.layer(i);\n    if (currLayer.name === \"Background\") continue;\n    if (!(currLayer instanceof AVLayer)) continue;\n    let newLayer = newComp.layers.add(currLayer.source);\n    const scaleFactor = getScaleFactor(newLayer, newComp, layerArray[i - 1].pan);\n    let layerObj = {\n      name: comp.layer(i).name,\n      index: i,\n      layer: newLayer,\n      count: layerArray[i - 1].count,\n      in: layerArray[i - 1].in,\n      out: layerArray[i - 1].out,\n      scaleFactor: scaleFactor,\n      pan: layerArray[i - 1].pan,\n      padding: layerArray[i - 1].padding,\n      prev: layerArray[i - 1].prev,\n      darken: layerArray[i - 1].darken,\n    };\n    layers.push(layerObj);\n  }\n  return layers;\n};\n\nexport const getScaleFactor = (currLayer: AVLayer, comp: CompItem, pan: boolean) => {\n  let layerScale = currLayer.property(\"Scale\");\n  if (!(layerScale instanceof Property)) return 1;\n  let scaleFactorY = 100;\n  let scaleFactorX = 100;\n  if (currLayer.height > comp.height) {\n    scaleFactorY = comp.height / currLayer.height;\n  }\n  if (currLayer.width > comp.width) {\n    scaleFactorX = comp.width / currLayer.width;\n  }\n  let scaleFactor = Math.min(scaleFactorX, scaleFactorY, 1);\n  const ratio = currLayer.width / currLayer.height;\n  if (pan) scaleFactor = ((ratio - 1) / 2 + 1) * scaleFactor;\n  return scaleFactor;\n};\n\nexport const shouldPan = (layer: AVLayer) => {\n  const ratio = layer.width / layer.height;\n  return ratio > 1.5;\n};\n\n// ALERT EASE VALUES\nconst alertEaseValues = (comp: CompItem) => {\n  let layerPos = comp.selectedLayers[0].property(\"Position\");\n  if (layerPos instanceof Property) {\n    for (let j = 1; j <= layerPos.numKeys; j++) {\n      for (let i = 0; i < layerPos.keyInTemporalEase(1).length; i++) {\n        alert(\n          j +\n            \" Ease In: \" +\n            layerPos.keyInTemporalEase(j)[i].influence +\n            \" \" +\n            layerPos.keyInTemporalEase(j)[i].speed\n        );\n      }\n    }\n\n    for (let j = 1; j <= layerPos.numKeys; j++) {\n      for (let i = 0; i < layerPos.keyOutTemporalEase(1).length; i++) {\n        alert(\n          j +\n            \" Ease Out: \" +\n            layerPos.keyOutTemporalEase(j)[i].influence +\n            \" \" +\n            layerPos.keyOutTemporalEase(j)[i].speed\n        );\n      }\n    }\n  }\n};\n\nexport const getLayerProps = (layer: Layer) => {\n  let layerOpacity = layer.property(\"Opacity\");\n  let layerPos = layer.property(\"Position\");\n  let layerScale = layer.property(\"Scale\");\n  return [layerOpacity as Property, layerPos as Property, layerScale as Property];\n};\n\nexport const getAnimDirection = (layer: Layer) => {\n  let layerPos = layer.property(\"Position\");\n  if (!(layerPos instanceof Property)) return \"none\";\n  const positionOne = layerPos.valueAtTime(0, false);\n  const positionTwo = layerPos.valueAtTime(2, false);\n  if (positionOne[0] !== positionTwo[0]) return \"left\";\n  else if (positionOne[1] !== positionTwo[1]) return \"down\";\n  return \"none\";\n};\n\nexport const realHeight = (layer: AVLayer) => {\n  // alert(layer.height + \" \" + layer.scale.value[1] / 100 + \" \" + layer.name);\n  return layer.height * (layer.scale.value[1] / 100);\n};\n\nexport const realWidth = (layer: AVLayer) => {\n  return layer.width * (layer.scale.value[0] / 100);\n};\n\nexport const realHeightArr = (layer: LayerObj) => {\n  return layer.layer.height * layer.scaleFactor;\n};\n\nexport const realWidthArr = (layer: LayerObj) => {\n  return layer.layer.width * layer.scaleFactor;\n};\n\nexport const getNumRealLayers = (comp: CompItem) => {\n  let numLayers = 0;\n  for (let i = 1; i <= comp.numLayers; i++) {\n    if (comp.layer(i).name === \"Background\") {\n      continue;\n    }\n    numLayers++;\n  }\n  return numLayers;\n};\n","import {\n  LayerObj,\n  realHeight,\n  realHeightArr,\n  realWidth,\n  realWidthArr,\n} from \"./utils\";\nconst SCREEN_HEIGHT = 1920;\nconst SCREEN_WIDTH = 1080;\nconst TRANSITION_TIME = 2;\n\nexport const upOut = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevPos: number[],\n  layerOpacity: Property,\n  padding: number\n) => {\n  if (layerArray[slide].prev === \"keep\") {\n    const combinedHeight = realHeight(currLayer) + realHeightArr(layerArray[slide]);\n    if (slide === 1 && combinedHeight < SCREEN_HEIGHT) {\n      const screenCenter = SCREEN_HEIGHT / 2;\n      const topPosition = screenCenter - combinedHeight / 2;\n      const newCenter = topPosition + realHeight(currLayer) / 2 - padding;\n      layerPos.setValueAtTime(TRANSITION_TIME, [prevPos[0], newCenter]);\n    } else {\n      const newLayerHeight = realHeightArr(layerArray[slide]);\n      const bottomPanel = layerArray[slide - 1].layer;\n      let bottomPanelPos = bottomPanel.position.valueAtTime(15, false);\n      const bototomPanelParent = bottomPanel.parent;\n      if (bototomPanelParent) {\n        const childPosition = bottomPanel.position.valueAtTime(15, false);\n        let parentPosition = bototomPanelParent.transform.position.value;\n        bottomPanelPos = [\n          childPosition[0] + parentPosition[0],\n          childPosition[1] + parentPosition[1],\n        ];\n      }\n      const bottomPanelHeight = realHeight(bottomPanel);\n      let newPos =\n        prevPos[1] -\n        (newLayerHeight -\n          (SCREEN_HEIGHT - bottomPanelPos[1] - bottomPanelHeight / 2));\n      layerPos.setValueAtTime(TRANSITION_TIME, [prevPos[0], newPos]);\n    }\n  } else if (layerArray[slide].prev === \"flush\") {\n    layerPos.setValueAtTime(TRANSITION_TIME, [\n      prevPos[0],\n      (-1 * realHeightArr(layerArray[slide])) / 2,\n    ]);\n    layerOpacity.setValueAtTime(0, 100);\n    layerOpacity.setValueAtTime(TRANSITION_TIME, 0);\n  }\n};\n\nexport const noneOut = (layerPos: Property, prevPos: number[]) => {\n  layerPos.setValueAtTime(TRANSITION_TIME, prevPos);\n};\n\nexport const downIn = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevLayer: LayerObj\n) => {\n  layerPos.setValueAtTime(0, [SCREEN_WIDTH / 2, SCREEN_HEIGHT]);\n  if (layerArray[slide].prev === \"keep\") {\n    const combinedHeight =\n      realHeight(currLayer) + realHeightArr(layerArray[slide - 1]);\n    if (slide === 1 && combinedHeight < SCREEN_HEIGHT) {\n      const screenCenter = SCREEN_HEIGHT / 2;\n      const bottomPosition = screenCenter + combinedHeight / 2;\n      const newCenter = bottomPosition - realHeight(currLayer) / 2;\n      layerPos.setValueAtTime(TRANSITION_TIME, [SCREEN_WIDTH / 2, newCenter]);\n    } else {\n      let newPos = SCREEN_HEIGHT - realHeight(currLayer) / 2;\n      layerPos.setValueAtTime(TRANSITION_TIME, [SCREEN_WIDTH / 2, newPos]);\n    }\n  } else {\n    layerPos.setValueAtTime(TRANSITION_TIME, [SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2]);\n  }\n};\n\nexport const leftIn = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevLayer: LayerObj\n) => {\n  if (layerArray[slide].prev === \"keep\") {\n    let verticalHeight = SCREEN_HEIGHT - realHeight(currLayer) / 2;\n    layerPos.setValueAtTime(0, [-540, verticalHeight]);\n    let calcVal = realWidth(currLayer) / 2;\n    layerPos.setValueAtTime(TRANSITION_TIME, [calcVal, verticalHeight]);\n  } else {\n    layerPos.setValueAtTime(0, [-1 * SCREEN_WIDTH, SCREEN_HEIGHT / 2]);\n    layerPos.setValueAtTime(TRANSITION_TIME, [SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2]);\n  }\n};\n\nexport const fadeOut = (layerOpacity: Property) => {\n  layerOpacity.setValueAtTime(0, 100);\n  layerOpacity.setValueAtTime(1, 0);\n};\n\nexport const fadeIn = (layerOpacity: Property) => {\n  layerOpacity.setValueAtTime(0, 0);\n  layerOpacity.setValueAtTime(1, 100);\n};\n\nexport const rightOut = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevPos: number[],\n  layerOpacity: Property,\n  padding: number\n) => {\n  if (layerArray[slide].prev === \"keep\") {\n    const newLayerWidth = realWidthArr(layerArray[slide]);\n    const leftPanel = layerArray[slide - 1].layer;\n    const leftPanelPos = leftPanel.position.valueAtTime(2, false)[0];\n    const leftPanelWidth = realWidth(leftPanel);\n    const newPos =\n      prevPos[0] +\n      (newLayerWidth - (SCREEN_WIDTH - leftPanelPos - leftPanelWidth / 2));\n    layerPos.setValueAtTime(TRANSITION_TIME, [newPos, prevPos[1]]);\n  } else {\n    layerPos.setValueAtTime(TRANSITION_TIME, [\n      SCREEN_WIDTH + realWidth(currLayer) / 2,\n      prevPos[1],\n    ]);\n    layerOpacity.setValueAtTime(0, 100);\n    layerOpacity.setValueAtTime(TRANSITION_TIME, 0);\n  }\n};\n","export const fastSlowEase = [\n  new KeyframeEase(0, 83.5),\n  new KeyframeEase(0, 0.1),\n  new KeyframeEase(11.5, 83.5),\n  new KeyframeEase(0, 0.1),\n];\n\nexport const slowFastSlow = [\n  new KeyframeEase(0, 90),\n  new KeyframeEase(0, 90),\n  new KeyframeEase(0, 90),\n  new KeyframeEase(0, 90),\n];\n","import {\n  LayerObj,\n  getLayerProps,\n  getScaleFactor,\n  realHeight,\n  realWidth,\n} from \"./utils\";\nimport {\n  downIn,\n  fadeIn,\n  fadeOut,\n  leftIn,\n  noneOut,\n  rightOut,\n  upOut,\n} from \"./subAnimations\";\nimport { fastSlowEase, slowFastSlow } from \"./easeValues\";\n\nexport const animateLayer = (\n  currLayer: AVLayer,\n  slide: number, // current slide, e.g 7_1, 7_2, 7_3\n  index: number, // current layer index, e.g 0, 1, 2\n  layerArray: LayerObj[],\n  newComp: CompItem,\n  darkenIndex: number\n) => {\n  if (slide === index) {\n    animateLayerIn(currLayer, layerArray, index, slide);\n    if (darkenIndex != -1 && darkenIndex <= slide) {\n      let darkBG = newComp.layers.addSolid([0, 0, 0], \"Darken\", 1080, 1920, 55);\n      let darkBGOpacity = darkBG.property(\"Opacity\");\n      if (!(darkBGOpacity instanceof Property)) return;\n      darkBGOpacity.setValueAtTime(1.5, 55);\n      if (darkenIndex === slide) {\n        darkBGOpacity.setValueAtTime(0, 0);\n      }\n      darkBG.moveAfter(newComp.layer(slide - darkenIndex + 2));\n    }\n    if (layerArray[index].pan) {\n      panLayer(currLayer, newComp);\n    }\n  } else {\n    animateLayerOut(currLayer, layerArray, index, slide);\n  }\n};\n\nconst animateLayerIn = (\n  currLayer: AVLayer,\n  layerArray: LayerObj[],\n  index: number,\n  slide: number\n) => {\n  let layerPos = currLayer.property(\"Position\");\n  let layerOpacity = currLayer.property(\"Opacity\");\n  let layerScale = currLayer.property(\"Scale\");\n  let prevLayer = layerArray[index - 1];\n\n  if (!(layerPos instanceof Property)) return;\n  if (!(layerOpacity instanceof Property)) return;\n  if (!(layerScale instanceof Property)) return;\n\n  if (layerArray[slide].in === \"down\") {\n    downIn(layerArray, slide, currLayer, layerPos, prevLayer);\n  } else if (layerArray[slide].in === \"left\") {\n    leftIn(layerArray, slide, currLayer, layerPos, prevLayer);\n  } else if (layerArray[slide].in === \"fade\") {\n    fadeIn(layerOpacity);\n    return;\n  }\n  // Set the ease to be a smooth bezier.\n  layerPos.setTemporalEaseAtKey(1, [fastSlowEase[0]], [fastSlowEase[1]]);\n  layerPos.setTemporalEaseAtKey(2, [fastSlowEase[2]], [fastSlowEase[3]]);\n  fadeIn(layerOpacity);\n};\n\nconst animateLayerOut = (\n  currLayer: AVLayer,\n  layerArray: LayerObj[],\n  index: number,\n  slide: number\n) => {\n  const [layerOpacity, layerPos, layerScale] = getLayerProps(currLayer);\n\n  let prevPos = layerArray[index].layer.position.valueAtTime(15, false);\n  let parentLayer = layerArray[index].layer.parent;\n  if (parentLayer) {\n    let childPosition = layerArray[index].layer.position.valueAtTime(15, false);\n    let parentPosition = parentLayer.position.valueAtTime(15, false);\n    prevPos = [\n      childPosition[0] + parentPosition[0],\n      childPosition[1] + parentPosition[1],\n    ];\n  }\n  layerPos.setValueAtTime(0, prevPos);\n  if (layerArray[slide].darken) return;\n\n  if (layerArray[index].out[slide - 1 - index] === \"up\") {\n    upOut(\n      layerArray,\n      slide,\n      currLayer,\n      layerPos,\n      prevPos,\n      layerOpacity,\n      layerArray[index].padding\n    );\n  } else if (layerArray[index].out[slide - 1 - index] === \"right\") {\n    rightOut(\n      layerArray,\n      slide,\n      currLayer,\n      layerPos,\n      prevPos,\n      layerOpacity,\n      layerArray[index].padding\n    );\n  } else if (layerArray[index].out[slide - 1 - index] === \"fade\") {\n    fadeOut(layerOpacity);\n  } else if (layerArray[index].out[slide - 1 - index] === \"none\") {\n    noneOut(layerPos, prevPos);\n  } else if (layerArray[index].out[slide - 1 - index] === \"x\") {\n    alert(\"bruh\");\n  }\n\n  // Set the ease to be a smooth bezier.\n  if (layerArray[index].out[slide - 1 - index] !== \"fade\") {\n    layerPos.setTemporalEaseAtKey(1, [fastSlowEase[0]], [fastSlowEase[1]]);\n    layerPos.setTemporalEaseAtKey(2, [fastSlowEase[2]], [fastSlowEase[3]]);\n  }\n};\n\nexport const panLayer = (curr: Layer, compItem: CompItem) => {\n  if (!curr) app.beginUndoGroup(\"Pan Layer\");\n  let comp = compItem;\n  let activeComp = app.project.activeItem;\n  if (!(activeComp instanceof CompItem)) return;\n  if (!compItem) comp = activeComp;\n  if (!curr) curr = comp.selectedLayers[0];\n  if (!(curr instanceof AVLayer)) return;\n  let newNull = comp.layers.addNull();\n  let newNullPos = newNull.property(\"Position\");\n  let currPos = curr.property(\"Position\");\n  if (!(currPos instanceof Property)) return;\n  if (!(newNullPos instanceof Property)) return;\n  let oldPos = currPos.valueAtTime(15, true);\n  curr.parent = newNull;\n  // alert(oldPos[1] + \" \" + newNull.position.value[1] + \" \" + curr.position.value[1]);\n  const myMarker = new MarkerValue(\"Pan End\");\n  myMarker.label = 4;\n  comp.markerProperty.setValueAtTime(6, myMarker);\n  newNullPos.setValueAtTime(0, [\n    1080 - realWidth(curr) / 2,\n    newNull.position.value[1],\n  ]);\n  newNullPos.setValueAtTime(6, [\n    (curr.width * (curr.scale.value[0] / 100)) / 2,\n    newNull.position.value[1],\n  ]);\n  newNullPos.setTemporalEaseAtKey(1, [slowFastSlow[0]], [slowFastSlow[1]]);\n  newNullPos.setTemporalEaseAtKey(2, [slowFastSlow[2]], [slowFastSlow[3]]);\n  if (!curr) app.endUndoGroup();\n};\n","export const forEachLayer = (\r\n  comp: CompItem,\r\n  callback: (item: Layer, index: number) => void\r\n) => {\r\n  const len = comp.numLayers;\r\n  for (let i = 1; i < len + 1; i++) {\r\n    callback(comp.layers[i], i);\r\n  }\r\n};\r\n\r\nexport const compFromFootage = (item: FootageItem): CompItem => {\r\n  return app.project.items.addComp(\r\n    item.name,\r\n    item.width,\r\n    item.height,\r\n    item.pixelAspect,\r\n    item.duration,\r\n    item.frameRate\r\n  );\r\n};\r\n\r\nexport const getProjectDir = () => {\r\n  app.project.file;\r\n  if (app.project.file !== null) {\r\n    //@ts-ignore\r\n    return app.project.file.parent;\r\n  } else {\r\n    return \"\";\r\n  }\r\n};\r\n\r\nexport const getActiveComp = () => {\r\n  if (app.project.activeItem instanceof CompItem === false) {\r\n    app.activeViewer?.setActive();\r\n  }\r\n  return app.project.activeItem as CompItem;\r\n};\r\n\r\n// Metadata helpers\r\n\r\nexport const setAeMetadata = (propName: string, propValue: any) => {\r\n  if (ExternalObject.AdobeXMPScript === undefined) {\r\n    ExternalObject.AdobeXMPScript = new ExternalObject(\"lib:AdobeXMPScript\");\r\n  }\r\n  if (!app.project || !ExternalObject.AdobeXMPScript || !XMPMeta) return;\r\n  const prefix = \"xmp:\";\r\n  const uri = XMPMeta.getNamespaceURI(prefix);\r\n  const newPropName = prefix + propName;\r\n  let metadata = new XMPMeta(app.project.xmpPacket);\r\n  metadata.setProperty(uri, newPropName, propValue.toString());\r\n  app.project.xmpPacket = metadata.serialize();\r\n};\r\n\r\nexport const getAeMetadata = (propName: string) => {\r\n  if (ExternalObject.AdobeXMPScript === undefined) {\r\n    ExternalObject.AdobeXMPScript = new ExternalObject(\"lib:AdobeXMPScript\");\r\n  }\r\n  if (!app.project || !ExternalObject.AdobeXMPScript || !XMPMeta) return;\r\n  const prefix = \"xmp:\";\r\n  const uri = XMPMeta.getNamespaceURI(prefix);\r\n  const newPropName = prefix + propName;\r\n  const metadata = new XMPMeta(app.project.xmpPacket);\r\n  return metadata.getProperty(uri, newPropName);\r\n};\r\n","import {\n  getAnimDirection,\n  getLayerProps,\n  getNumRealLayers,\n  getLayers,\n  getScaleFactor,\n  shouldPan,\n} from \"./utils\";\nimport { animateLayer, panLayer } from \"./animate\";\nexport { panLayer };\nimport { forEachLayer } from \"./aeft-utils\";\n\ntype LayerObj = {\n  name: string;\n  index: number;\n  count: number;\n  in: string;\n  out: string[];\n  prev: string;\n  darken: boolean;\n  pan: boolean;\n  padding: number;\n};\n\nexport const animatePhotoshop = (layerArray: LayerObj[]) => {\n  app.beginUndoGroup(\"Split Comp\");\n  let comp = app.project.activeItem;\n  if (!(comp instanceof CompItem)) return;\n  let newFolder = app.project.items.addFolder(\"Page_\" + comp.name);\n  if (layerArray.length == 0) layerArray = getPanels();\n  let layers = getLayers(comp, layerArray, newFolder);\n  let currentCount = 1;\n  let darkenIndex = -1;\n  let comps = [];\n  for (let i = 0; i < layers.length; i++) {\n    for (let k = 0; k < layers[i].count; k++) {\n      let newComp = app.project.items.addComp(\n        comp.name + \"_\" + currentCount,\n        1080,\n        1920,\n        1,\n        15,\n        24\n      );\n      comps.push(newComp);\n      newComp.parentFolder = newFolder;\n      newComp.layers.addSolid([255, 255, 255], \"Background\", 1080, 1920, 1);\n      const newMarker = new MarkerValue(\"Anim End\");\n      newMarker.label = 3;\n      newComp.markerProperty.setValueAtTime(2, newMarker);\n      for (let j = 0; j <= i; j++) {\n        let currentLayer = layers[j].layer;\n        if (!(currentLayer instanceof AVLayer)) continue;\n        if (i != j && layerArray[j].out[i - 1 - j] === \"x\") {\n          continue;\n        }\n        let newLayer = newComp.layers.add(currentLayer.source);\n        let newLayerScale = newLayer.property(\"Scale\");\n        if (!(newLayerScale instanceof Property)) continue;\n        newLayerScale.setValue([\n          layers[j].scaleFactor * 100,\n          layers[j].scaleFactor * 100,\n        ]);\n        if (layerArray[i].darken) darkenIndex = i;\n        if (i != 0 && k == 0)\n          animateLayer(newLayer, i, j, layers, newComp, darkenIndex);\n        layers[j].layer = newLayer;\n      }\n      currentCount++;\n    }\n  }\n  for (let i = comps.length - 1; i >= 0; i--) {\n    comps[i].openInViewer();\n  }\n  app.endUndoGroup();\n  return;\n};\n\nexport const render = () => {\n  let outputFolder = new Folder(app.project.file?.parent.fsName + \"/output\");\n  outputFolder.create();\n  for (let i = 1; i <= app.project.numItems; i++) {\n    let currentFolder = app.project.item(i);\n    if (!(currentFolder instanceof FolderItem)) continue;\n    if (currentFolder.name.indexOf(\"Page_\") < 0) continue;\n    for (let j = 1; j <= currentFolder.numItems; j++) {\n      let currentComp = currentFolder.item(j);\n      if (!(currentComp instanceof CompItem)) continue;\n      if (currentComp.name === \"internal\") continue;\n      let greatest = 0;\n      forEachLayer(currentComp, (layer) => {\n        let layerOpacity = layer.property(\"Opacity\");\n        if (!(layerOpacity instanceof Property)) return;\n        let layerPos = layer.property(\"Position\");\n        if (!(layerPos instanceof Property)) return;\n        let layerScale = layer.property(\"Scale\");\n        if (!(layerScale instanceof Property)) return;\n        let greateastTime = 0;\n        for (let k = 1; k <= layerOpacity.numKeys; k++) {\n          if (layerOpacity.keyTime(k) > greateastTime)\n            greateastTime = layerOpacity.keyTime(k);\n        }\n        for (let k = 1; k <= layerPos.numKeys; k++) {\n          if (layerPos.keyTime(k) > greateastTime)\n            greateastTime = layerPos.keyTime(k);\n        }\n        for (let k = 1; k <= layerScale.numKeys; k++) {\n          if (layerScale.keyTime(k) > greateastTime)\n            greateastTime = layerScale.keyTime(k);\n        }\n        greatest = Math.max(greatest, greateastTime);\n      });\n      if (greatest > 0) currentComp.workAreaDuration = greatest;\n      else currentComp.workAreaDuration = 1;\n      let newItem = app.project.renderQueue.items.add(currentComp);\n      // newItem.outputModule(1).applyTemplate(\"H.264\");\n      newItem.outputModule(1).file = new File(\n        outputFolder.fsName + \"/\" + currentComp.name + \".mov\"\n      );\n      newItem\n        .outputModule(1)\n        .applyTemplate(\"H.264 - Match Render Settings -  5 Mbps\");\n    }\n  }\n};\n\nexport const getPanels = (): LayerObj[] => {\n  let comp = app.project.activeItem;\n  if (!(comp instanceof CompItem)) return [];\n  let layers = [];\n  const numLayers = getNumRealLayers(comp);\n  for (let i = 1; i <= numLayers; i++) {\n    if (comp.layer(i).name === \"Background\") continue;\n    let out = [];\n    for (let j = numLayers; j > i; j--) {\n      out.push(\"up\");\n    }\n    let inAnim = \"down\";\n    const currLayer = comp.layer(i);\n    if (!(currLayer instanceof AVLayer)) continue;\n    const pan = shouldPan(currLayer);\n    if (currLayer.height > currLayer.width) {\n      inAnim = \"left\";\n      // if (prevLayer) prevLayer.out[0] = \"right\";\n      for (let j = 0; j < layers.length; j++) {\n        layers[j].out[i - j - 2] = \"right\";\n      }\n    }\n    const layerObj: LayerObj = {\n      name: comp.layer(i).name,\n      index: i,\n      count: 1,\n      in: inAnim,\n      out: out,\n      prev: \"keep\",\n      pan: pan,\n      padding: 100,\n      darken: false,\n    };\n    layers.push(layerObj);\n  }\n  return layers;\n};\n\nexport const addAudios = () => {\n  //Import all files in the audio folder\n  app.beginUndoGroup(\"Add Audio\");\n  let audioContainer = app.project.items.addFolder(\"Voice-Lines\");\n  let audioFolder = new Folder(app.project.file?.parent.fsName + \"/voice-lines\");\n  let audioFiles = audioFolder.getFiles();\n  for (let i = 0; i < audioFiles.length; i++) {\n    let currentFile = audioFiles[i];\n    if (!(currentFile instanceof File)) continue;\n    let audioImport = app.project.importFile(new ImportOptions(currentFile));\n    audioImport.parentFolder = audioContainer;\n  }\n  for (let i = 1; i <= app.project.numItems; i++) {\n    let currentFolder = app.project.item(i);\n    if (!(currentFolder instanceof FolderItem)) continue;\n    if (currentFolder.name.indexOf(\"Page_\") < 0) continue;\n    for (let j = 1; j <= currentFolder.numItems; j++) {\n      let currentComp = currentFolder.item(j);\n      if (!(currentComp instanceof CompItem)) continue;\n      if (currentComp.name === \"internal\") continue;\n      for (let k = 1; k <= audioContainer.numItems; k++) {\n        let currentAudio = audioContainer.item(k);\n        if (!(currentAudio instanceof FootageItem)) continue;\n        if (currentAudio.name.indexOf(currentComp.name) < 0) continue;\n        currentComp.layers.add(currentAudio);\n      }\n    }\n  }\n  app.endUndoGroup();\n};\n\nexport const updateValues = () => {\n  app.beginUndoGroup(\"Update Values\");\n  let comp = app.project.activeItem;\n  if (!(comp instanceof CompItem)) return;\n  let layers = [];\n  for (let i = 1; i <= comp.numLayers; i++) {\n    let layerObj = {\n      name: comp.layer(i).name,\n      index: i,\n      layer: comp.layer(i),\n    };\n    layers.push(layerObj);\n  }\n\n  const parentFolder = comp.parentFolder;\n  let pastCurrentComp = false;\n  for (let i = 1; i <= parentFolder.numItems; i++) {\n    if (pastCurrentComp) {\n      let currentComp = parentFolder.item(i);\n      if (!(currentComp instanceof CompItem)) continue;\n      for (let j = 1; j <= currentComp.numLayers; j++) {\n        let currentLayer = currentComp.layer(j);\n        for (let k = 0; k < layers.length; k++) {\n          if (layers[k].name !== currentLayer.name) continue;\n          const [currOpacity, currPos, currScale] = getLayerProps(currentLayer);\n          const [oldOpacity, oldPos, oldScale] = getLayerProps(layers[k].layer);\n          let parentLayer = layers[k].layer.parent;\n          let actualPosition = oldPos.valueAtTime(15, true);\n          if (parentLayer) {\n            var childPosition = layers[k].layer.transform.position.valueAtTime(\n              15,\n              false\n            );\n            var parentPosition = parentLayer.transform.position.valueAtTime(\n              15,\n              false\n            );\n            actualPosition = [\n              childPosition[0] + parentPosition[0],\n              childPosition[1] + parentPosition[1],\n            ];\n          }\n          const direction = getAnimDirection(currentLayer);\n          let currPosPrev = currPos.valueAtTime(2, true);\n          currPos.setValueAtTime(0, actualPosition);\n          currScale.setValueAtTime(0, oldScale.valueAtTime(15, false));\n          currOpacity.setValueAtTime(0, oldOpacity.valueAtTime(15, false));\n          if (direction === \"left\")\n            currPos.setValueAtTime(2, [currPosPrev[0], actualPosition[1]]);\n          if (direction === \"down\") {\n            currPos.setValueAtTime(2, [actualPosition[0], currPosPrev[1]]);\n          }\n        }\n      }\n      return;\n    }\n    if (parentFolder.item(i) == comp) pastCurrentComp = true;\n  }\n  app.endUndoGroup();\n};\n","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as aeft from \"./aeft/aeft\";\n\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\n\nswitch (BridgeTalk.appName as ApplicationName) {\n  case \"aftereffects\":\n  case \"aftereffectsbeta\":\n    host[ns] = aeft;\n    break;\n}\n\nexport type Scripts = typeof aeft\n\n// https://extendscript.docsforadobe.dev/interapplication-communication/bridgetalk-class.html?highlight=bridgetalk#appname\ntype ApplicationName =\n  | \"aftereffects\"\n  | \"aftereffectsbeta\"\n  | \"ame\"\n  | \"amebeta\"\n  | \"audition\"\n  | \"auditionbeta\"\n  | \"bridge\"\n  | \"bridgebeta\"\n  // | \"flash\"\n  | \"illustrator\"\n  | \"illustratorbeta\"\n  | \"indesign\"\n  | \"indesignbeta\"\n  // | \"indesignserver\"\n  | \"photoshop\"\n  | \"photoshopbeta\"\n  | \"premierepro\"\n  | \"premiereprobeta\";\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","installModules","copyAssets","copyZipAssets","index","layer","scaleFactor","darken","layers","scaleFactorY","scaleFactorX","numLayers","layerPos","layerOpacity","darkBGOpacity","darkBG","panLayer","layerScale","upOut","rightOut","noneOut","newNullPos","app","comps","currentCount","forEachLayer","_ret","out","inAnim","count","prev","pan","padding","currentComp","currOpacity","currPos","currScale","oldOpacity","oldPos","oldScale","host"],"mappings":";;AAGA;AACEA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAAUC;AAAcV;AAAsB;AAC9CW;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEAC;AAEIC;AACAV;AACAW;AACAC;AACAL;AACAC;AACF;AAEFK;AACEC;AACAC;;AAEFC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;AAEFQ;AACAC;AACAC;AACF;;AChDA;;ACaA;;;;AAQE;AACE;AACA;AACA;;AAEA;AACA;;AAEEC;AACAC;;AAEA;;AAEAC;;;;AAIAC;;AAEFC;AACF;AACA;AACF;AAEA;AACE;AACA;;;AAGA;AACEC;AACF;AACA;AACEC;AACF;;;AAGA;AACA;AACF;AAEA;;;AAGA;AAgCA;AACE;AACA;AACA;AACA;AACF;AAEA;AACE;AACA;;;;AAKA;AACF;AAEA;AACE;AACA;AACF;AAEA;AACE;AACF;AAEA;;AAEA;AAEA;;AAEA;AAEA;;AAEE;;AAEI;AACF;AACAC;AACF;AACA;AACF;;ACtIA;AACA;AACA;AAEA;;AAUI;AACA;AACE;AACA;;AAEAC;AACF;;;;AAIE;AACA;;;;AAOA;AACA;;AAKAA;AACF;;;AAMAC;AACAA;AACF;AACF;AAEA;AACED;AACF;AAEA;AAOEA;;AAEE;AAEA;AACE;AACA;;AAEAA;AACF;;AAEEA;AACF;AACF;AACEA;AACF;AACF;AAEA;;;;AAUI;;AAEF;AACEA;AACAA;AACF;AACF;AAEA;AACEC;AACAA;AACF;AAEA;AACEA;AACAA;AACF;AAEA;;;;AAYI;AACA;AACA;AAGAD;AACF;;AAKEC;AACAA;AACF;AACF;;AC5IA;AAOA;;;;;;;;ACWA;;;;;AAYM;AACA;AACAC;;AAEEA;AACF;AACAC;AACF;AACA;AACEC;AACF;AACF;;AAEA;AACF;AAEA;AAME;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAME;AACF;AACA;AACAJ;AACAA;;AAEF;AAEA;AAME;;AAAOC;AAAcD;AAAUK;AAE/B;;AAEA;AACE;;;AAMF;AACAL;AACA;AAEA;AACEM;AASF;AACEC;AASF;;AAEA;AACEC;AACF;;AAEA;;AAEA;AACA;AACER;AACAA;AACF;AACF;AAEA;;;AAGE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;;;AAOAS;AAIAA;AACAA;AACA;AACF;;ACjKA;AAIE;AACA;;AAEA;AACF;;;;;;;;ACgBA;AACEC;AACA;AACA;AACA;;;;;;AAMA;AACE;;AASEC;;;AAGA;;;;AAIE;AACA;AACA;AACE;AACF;;AAEA;AACA;;;;AAQAf;AACF;AACAgB;AACF;AACF;AACA;AACED;AACF;;AAEA;AACF;AAEA;AAA4B;;;AAG1B;;AAEE;;;AAGE;AACA;AACA;;AAEAE;AACE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACE;AAEF;AACA;AACE;AAEF;AACA;AACE;AAEF;;AAEF;AACA;AAEA;AACA;;;;;AA9BF;AAAgDC;AAAA;AAEG;AAoCrD;AACF;AAEA;AACE;AACA;;AAEA;;;;;AAKIC;AACF;;AAEA;AACA;AACA;AACA;AACEC;AACA;AACA;AACEpB;AACF;AACF;AACA;;AAEEJ;AACAyB;AACA;AACAF;AACAG;AACAC;AACAC;AACAzB;;AAEFC;AACF;AACA;AACF;AAEA;AAA+B;AAC7B;AACAc;;;AAGA;AACA;AACE;AACA;AACA;;AAEF;AACA;;AAEE;;AAEA;AACE;AACA;AACA;AACA;AACE;AACA;AACA;AACAW;AACF;AACF;AACF;;AAEF;AAEA;AACEX;AACA;AACA;;AAEA;AACE;;AAEElB;AACAC;;AAEFG;AACF;AAEA;;AAEA;AACE;AACE;AACA;AACA;AACE;AACA;;AAEE;;AAAO0B;AAAaC;AAASC;;;AACtBC;AAAYC;AAAQC;;;AAG3B;AACE;AAIA;;AAQF;AACA;;AAEAJ;AACAC;AACAF;;;AAIEC;AACF;AACF;AACF;AACA;AACF;;AAEF;;AAEF;;;;;;;;;;;;ACvPA;AAEA;AACE;AACA;AACEK;AACA;AACJ;;AAIA"}