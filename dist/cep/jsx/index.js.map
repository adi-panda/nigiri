{"version":3,"file":"index.js","sources":["../../../cep.config.ts","../../../src/shared/shared.ts","../../../src/jsx/aeft/utils.ts","../../../src/jsx/aeft/subAnimations.ts","../../../src/jsx/aeft/easeValues.ts","../../../src/jsx/aeft/animate.ts","../../../src/jsx/aeft/aeft-utils.ts","../../../src/jsx/aeft/aeft.ts","../../../src/jsx/index.ts"],"sourcesContent":["import { CEP_Config } from \"vite-cep-plugin\";\nimport { version } from \"./package.json\";\n\nconst config: CEP_Config = {\n  version,\n  id: \"com.toona.nigiri\",\n  displayName: \"Nigiri\",\n  symlink: \"local\",\n  port: 3005,\n  servePort: 5000,\n  startingDebugPort: 8860,\n  extensionManifestVersion: 6.0,\n  requiredRuntimeVersion: 9.0,\n  hosts: [{ name: \"AEFT\", version: \"[0.0,99.9]\" }],\n  type: \"Panel\",\n  iconDarkNormal: \"./src/assets/light-icon.png\",\n  iconNormal: \"./src/assets/dark-icon.png\",\n  iconDarkNormalRollOver: \"./src/assets/light-icon.png\",\n  iconNormalRollOver: \"./src/assets/dark-icon.png\",\n  parameters: [\"--v=0\", \"--enable-nodejs\", \"--mixed-context\"],\n  width: 500,\n  height: 550,\n\n  panels: [\n    {\n      mainPath: \"./main/index.html\",\n      name: \"main\",\n      panelDisplayName: \"Nigiri\",\n      autoVisible: true,\n      width: 600,\n      height: 650,\n    },\n  ],\n  build: {\n    jsxBin: \"off\",\n    sourceMap: true,\n  },\n  zxp: {\n    country: \"US\",\n    province: \"CA\",\n    org: \"MyCompany\",\n    password: \"mypassword\",\n    tsa: \"http://timestamp.digicert.com/\",\n    sourceMap: false,\n    jsxBin: \"off\",\n  },\n  installModules: [],\n  copyAssets: [],\n  copyZipAssets: [],\n};\nexport default config;\n","import config from \"../../cep.config\";\r\nexport const ns = config.id;\r\n","export type LayerObj = {\n  name: string;\n  index: number;\n  layer: AVLayer;\n  count: number;\n  scaleFactor: number;\n  in: string;\n  out: string;\n  prev: string;\n  darken: boolean;\n};\n\nexport const sortLayers = (\n  comp: CompItem,\n  layerArray: any[],\n  parentFold: FolderItem\n): LayerObj[] => {\n  let layers = [];\n  let newComp = app.project.items.addComp(\"internal\", 1080, 1920, 1, 15, 24);\n  newComp.parentFolder = parentFold;\n  for (let i = 1; i <= comp.numLayers; i++) {\n    let currLayer = comp.layer(i);\n    if (!(currLayer instanceof AVLayer)) continue;\n    let newLayer = newComp.layers.add(currLayer.source);\n    let scaleFactor = getScaleFactor(newLayer, newComp);\n    let layerObj = {\n      name: comp.layer(i).name,\n      index: i,\n      layer: newLayer,\n      count: layerArray[i - 1].count,\n      in: layerArray[i - 1].in,\n      out: layerArray[i - 1].out,\n      scaleFactor: scaleFactor,\n      prev: layerArray[i - 1].prev,\n      darken: layerArray[i - 1].darken,\n    };\n    layers.push(layerObj);\n  }\n  layers.sort((a, b) => {\n    if (parseInt(a.name) < parseInt(b.name)) {\n      return -1;\n    }\n    if (parseInt(a.name) > parseInt(b.name)) {\n      return 1;\n    }\n    return 0;\n  });\n  return layers;\n};\n\nexport const getScaleFactor = (currLayer: AVLayer, comp: CompItem) => {\n  let layerScale = currLayer.property(\"Scale\");\n  if (!(layerScale instanceof Property)) return 1;\n  let scaleFactorY = 100;\n  let scaleFactorX = 100;\n  if (currLayer.height > comp.height) {\n    scaleFactorY = comp.height / currLayer.height;\n  }\n  if (currLayer.width > comp.width) {\n    scaleFactorX = comp.width / currLayer.width;\n  }\n  let scaleFactor = Math.min(scaleFactorX, scaleFactorY, 1);\n  return scaleFactor;\n};\n\n// ALERT EASE VALUES\nconst alertEaseValues = (comp: CompItem) => {\n  let layerPos = comp.selectedLayers[0].property(\"Position\");\n  if (layerPos instanceof Property) {\n    for (let j = 1; j <= layerPos.numKeys; j++) {\n      for (let i = 0; i < layerPos.keyInTemporalEase(1).length; i++) {\n        alert(\n          j +\n            \" Ease In: \" +\n            layerPos.keyInTemporalEase(j)[i].influence +\n            \" \" +\n            layerPos.keyInTemporalEase(j)[i].speed\n        );\n      }\n    }\n\n    for (let j = 1; j <= layerPos.numKeys; j++) {\n      for (let i = 0; i < layerPos.keyOutTemporalEase(1).length; i++) {\n        alert(\n          j +\n            \" Ease Out: \" +\n            layerPos.keyOutTemporalEase(j)[i].influence +\n            \" \" +\n            layerPos.keyOutTemporalEase(j)[i].speed\n        );\n      }\n    }\n  }\n};\n\nexport const getLayerProps = (layer: Layer) => {\n  let layerOpacity = layer.property(\"Opacity\");\n  let layerPos = layer.property(\"Position\");\n  let layerScale = layer.property(\"Scale\");\n  return [layerOpacity as Property, layerPos as Property, layerScale as Property];\n};\n\nexport const getAnimDirection = (layer: Layer) => {\n  let layerPos = layer.property(\"Position\");\n  if (!(layerPos instanceof Property)) return \"none\";\n  const positionOne = layerPos.valueAtTime(0, false);\n  const positionTwo = layerPos.valueAtTime(2, false);\n  if (positionOne[0] !== positionTwo[0]) return \"left\";\n  else if (positionOne[1] !== positionTwo[1]) return \"down\";\n  return \"none\";\n};\n","import { LayerObj } from \"./utils\";\n\nexport const upOut = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevPos: number[],\n  layerOpacity: Property\n) => {\n  if (layerArray[slide].prev === \"keep\") {\n    if (slide === 1) {\n      let topAligned = (currLayer.height * (currLayer.scale.value[1] / 100)) / 2;\n      layerPos.setValueAtTime(2, [prevPos[0], topAligned]);\n    } else {\n      let newLayerHeight =\n        layerArray[slide].layer.height * layerArray[slide].scaleFactor;\n      let calcVal =\n        prevPos[1] -\n        (newLayerHeight -\n          (1920 -\n            layerArray[slide - 1].layer.position.valueAtTime(2, false)[1] -\n            (layerArray[slide - 1].layer.height *\n              layerArray[slide - 1].scaleFactor) /\n              2));\n\n      layerPos.setValueAtTime(2, [prevPos[0], calcVal]);\n    }\n  } else {\n    layerPos.setValueAtTime(2, [\n      prevPos[0],\n      (-1 * layerArray[slide].layer.height) / 2,\n    ]);\n    layerOpacity.setValueAtTime(0, 100);\n    layerOpacity.setValueAtTime(2, 0);\n  }\n};\n\nexport const downIn = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevLayer: LayerObj\n) => {\n  layerPos.setValueAtTime(0, [540, 1920]);\n  if (layerArray[slide].prev === \"keep\") {\n    if (slide === 1) {\n      layerPos.setValueAtTime(2, [\n        540,\n        prevLayer.layer.height * prevLayer.scaleFactor +\n          (currLayer.height * (currLayer.scale.value[1] / 100)) / 2,\n      ]);\n    } else {\n      let calcVal = 1920 - (currLayer.height * (currLayer.scale.value[1] / 100)) / 2;\n      layerPos.setValueAtTime(2, [540, calcVal]);\n    }\n  } else {\n    layerPos.setValueAtTime(2, [540, 960]);\n  }\n};\n\nexport const leftIn = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevLayer: LayerObj\n) => {\n  if (layerArray[slide].prev === \"keep\") {\n    let verticalHeight =\n      1920 - (currLayer.height * (currLayer.scale.value[1] / 100)) / 2;\n    layerPos.setValueAtTime(0, [-540, verticalHeight]);\n    let calcVal = 0 + (currLayer.width * (currLayer.scale.value[0] / 100)) / 2;\n    layerPos.setValueAtTime(2, [calcVal, verticalHeight]);\n  } else {\n    layerPos.setValueAtTime(0, [-540, 960]);\n    layerPos.setValueAtTime(2, [540, 960]);\n  }\n};\n\nexport const rightOut = (\n  layerArray: LayerObj[],\n  slide: number,\n  currLayer: AVLayer,\n  layerPos: Property,\n  prevPos: number[],\n  layerOpacity: Property\n) => {\n  if (layerArray[slide].prev === \"keep\") {\n    let newLayerWidth =\n      layerArray[slide].layer.width * layerArray[slide].scaleFactor;\n    let calcVal =\n      prevPos[0] +\n      (newLayerWidth -\n        (1080 -\n          layerArray[slide - 1].layer.position.valueAtTime(2, false)[0] -\n          (layerArray[slide - 1].layer.width * layerArray[slide - 1].scaleFactor) /\n            2));\n\n    layerPos.setValueAtTime(2, [calcVal, prevPos[1]]);\n  } else {\n    layerPos.setValueAtTime(2, [\n      1080 + (layerArray[slide].layer.width * layerArray[slide].scaleFactor) / 2,\n      960,\n    ]);\n    layerOpacity.setValueAtTime(0, 100);\n    layerOpacity.setValueAtTime(2, 0);\n  }\n};\n","export const fastSlowEase = [\n  new KeyframeEase(0, 83.5),\n  new KeyframeEase(0, 0.1),\n  new KeyframeEase(11.5, 83.5),\n  new KeyframeEase(0, 0.1),\n];\n\nexport const slowFastSlow = [\n  new KeyframeEase(0, 90),\n  new KeyframeEase(0, 90),\n  new KeyframeEase(0, 90),\n  new KeyframeEase(0, 90),\n];\n","import { LayerObj, getScaleFactor } from \"./utils\";\nimport { downIn, leftIn, rightOut, upOut } from \"./subAnimations\";\nimport { fastSlowEase } from \"./easeValues\";\n\nexport const animateLayer = (\n  currLayer: AVLayer,\n  slide: number, // current slide, e.g 7_1, 7_2, 7_3\n  index: number, // current layer index, e.g 0, 1, 2\n  layerArray: LayerObj[],\n  newComp: CompItem,\n  darkenIndex: number\n) => {\n  if (slide === index) {\n    animateLayerIn(currLayer, layerArray, index, slide);\n    if (darkenIndex != -1 && darkenIndex <= slide) {\n      let darkBG = newComp.layers.addSolid([0, 0, 0], \"Darken\", 1080, 1920, 55);\n      let darkBGOpacity = darkBG.property(\"Opacity\");\n      if (!(darkBGOpacity instanceof Property)) return;\n      darkBGOpacity.setValueAtTime(1.5, 55);\n      if (darkenIndex === slide) {\n        darkBGOpacity.setValueAtTime(0, 0);\n      }\n      darkBG.moveAfter(newComp.layer(slide - darkenIndex + 2));\n    }\n  } else {\n    animateLayerOut(currLayer, layerArray, index, slide);\n  }\n};\n\nconst animateLayerIn = (\n  currLayer: AVLayer,\n  layerArray: LayerObj[],\n  index: number,\n  slide: number\n) => {\n  let layerPos = currLayer.property(\"Position\");\n  let layerOpacity = currLayer.property(\"Opacity\");\n  let layerScale = currLayer.property(\"Scale\");\n  let prevLayer = layerArray[index - 1];\n\n  if (!(layerPos instanceof Property)) return;\n  if (!(layerOpacity instanceof Property)) return;\n  if (!(layerScale instanceof Property)) return;\n\n  layerScale.setValueAtTime(2, [currLayer.scale.value[0], currLayer.scale.value[0]]);\n\n  if (layerArray[slide].in === \"down\") {\n    downIn(layerArray, slide, currLayer, layerPos, prevLayer);\n  } else if (layerArray[slide].in === \"left\") {\n    leftIn(layerArray, slide, currLayer, layerPos, prevLayer);\n  }\n\n  // currLayer.height * (currLayer.scale.value[1] / 100);\n\n  // Set the ease to be a smooth bezier.\n  layerPos.setTemporalEaseAtKey(1, [fastSlowEase[0]], [fastSlowEase[1]]);\n  layerPos.setTemporalEaseAtKey(2, [fastSlowEase[2]], [fastSlowEase[3]]);\n\n  layerOpacity.setValueAtTime(0, 0);\n  layerOpacity.setValueAtTime(1, 100);\n};\n\nconst animateLayerOut = (\n  currLayer: AVLayer,\n  layerArray: LayerObj[],\n  index: number,\n  slide: number\n) => {\n  let layerPos = currLayer.property(\"Position\");\n  let layerOpacity = currLayer.property(\"Opacity\");\n  let layerScale = currLayer.property(\"Scale\");\n\n  if (!(layerPos instanceof Property)) return;\n  if (!(layerOpacity instanceof Property)) return;\n  if (!(layerScale instanceof Property)) return;\n\n  let prevPos = layerArray[index].layer.position.valueAtTime(2, false);\n  layerPos.setValueAtTime(0, prevPos);\n  if (layerArray[slide].darken) return;\n\n  if (layerArray[index].out[slide - 1 - index] === \"up\") {\n    upOut(layerArray, slide, currLayer, layerPos, prevPos, layerOpacity);\n  } else if (layerArray[index].out[slide - 1 - index] === \"right\") {\n    rightOut(layerArray, slide, currLayer, layerPos, prevPos, layerOpacity);\n  }\n\n  // Set the ease to be a smooth bezier.\n  layerPos.setTemporalEaseAtKey(1, [fastSlowEase[0]], [fastSlowEase[1]]);\n  layerPos.setTemporalEaseAtKey(2, [fastSlowEase[2]], [fastSlowEase[3]]);\n};\n","export const forEachLayer = (\r\n  comp: CompItem,\r\n  callback: (item: Layer, index: number) => void\r\n) => {\r\n  const len = comp.numLayers;\r\n  for (let i = 1; i < len + 1; i++) {\r\n    callback(comp.layers[i], i);\r\n  }\r\n};\r\n\r\nexport const compFromFootage = (item: FootageItem): CompItem => {\r\n  return app.project.items.addComp(\r\n    item.name,\r\n    item.width,\r\n    item.height,\r\n    item.pixelAspect,\r\n    item.duration,\r\n    item.frameRate\r\n  );\r\n};\r\n\r\nexport const getProjectDir = () => {\r\n  app.project.file;\r\n  if (app.project.file !== null) {\r\n    //@ts-ignore\r\n    return app.project.file.parent;\r\n  } else {\r\n    return \"\";\r\n  }\r\n};\r\n\r\nexport const getActiveComp = () => {\r\n  if (app.project.activeItem instanceof CompItem === false) {\r\n    app.activeViewer?.setActive();\r\n  }\r\n  return app.project.activeItem as CompItem;\r\n};\r\n\r\n// Metadata helpers\r\n\r\nexport const setAeMetadata = (propName: string, propValue: any) => {\r\n  if (ExternalObject.AdobeXMPScript === undefined) {\r\n    ExternalObject.AdobeXMPScript = new ExternalObject(\"lib:AdobeXMPScript\");\r\n  }\r\n  if (!app.project || !ExternalObject.AdobeXMPScript || !XMPMeta) return;\r\n  const prefix = \"xmp:\";\r\n  const uri = XMPMeta.getNamespaceURI(prefix);\r\n  const newPropName = prefix + propName;\r\n  let metadata = new XMPMeta(app.project.xmpPacket);\r\n  metadata.setProperty(uri, newPropName, propValue.toString());\r\n  app.project.xmpPacket = metadata.serialize();\r\n};\r\n\r\nexport const getAeMetadata = (propName: string) => {\r\n  if (ExternalObject.AdobeXMPScript === undefined) {\r\n    ExternalObject.AdobeXMPScript = new ExternalObject(\"lib:AdobeXMPScript\");\r\n  }\r\n  if (!app.project || !ExternalObject.AdobeXMPScript || !XMPMeta) return;\r\n  const prefix = \"xmp:\";\r\n  const uri = XMPMeta.getNamespaceURI(prefix);\r\n  const newPropName = prefix + propName;\r\n  const metadata = new XMPMeta(app.project.xmpPacket);\r\n  return metadata.getProperty(uri, newPropName);\r\n};\r\n","import { getAnimDirection, getLayerProps, sortLayers } from \"./utils\";\nimport { animateLayer } from \"./animate\";\nimport { slowFastSlow } from \"./easeValues\";\nimport { forEachLayer } from \"./aeft-utils\";\n\ntype LayerObj = {\n  name: string;\n  index: number;\n  count: number;\n  in: string;\n  out: string[];\n  prev: string;\n  darken: boolean;\n};\n\nexport const animatePhotoshop = (layerArray: LayerObj[]) => {\n  app.beginUndoGroup(\"Split Comp\");\n  let comp = app.project.activeItem;\n  if (!(comp instanceof CompItem)) return;\n  let newFolder = app.project.items.addFolder(\"Page_\" + comp.name);\n  if (layerArray.length == 0) layerArray = getPanels();\n  let layers = sortLayers(comp, layerArray, newFolder);\n  let currentCount = 1;\n  let darkenIndex = -1;\n  for (let i = 0; i < layers.length; i++) {\n    for (let k = 0; k < layers[i].count; k++) {\n      let newComp = app.project.items.addComp(\n        comp.name + \"_\" + currentCount,\n        1080,\n        1920,\n        1,\n        15,\n        24\n      );\n      newComp.parentFolder = newFolder;\n      newComp.layers.addSolid([255, 255, 255], \"Background\", 1080, 1920, 1);\n      for (let j = 0; j <= i; j++) {\n        let currentLayer = layers[j].layer;\n        if (!(currentLayer instanceof AVLayer)) continue;\n        let newLayer = newComp.layers.add(currentLayer.source);\n        let newLayerScale = newLayer.property(\"Scale\");\n        if (!(newLayerScale instanceof Property)) continue;\n        newLayerScale.setValue([\n          layers[j].scaleFactor * 100,\n          layers[j].scaleFactor * 100,\n        ]);\n        if (layerArray[i].darken) darkenIndex = i;\n        if (i != 0 && k == 0)\n          animateLayer(newLayer, i, j, layers, newComp, darkenIndex);\n        layers[j].layer = newLayer;\n      }\n      currentCount++;\n    }\n  }\n  app.endUndoGroup();\n  return;\n};\n\nexport const render = () => {\n  for (let i = 1; i <= app.project.numItems; i++) {\n    let currentFolder = app.project.item(i);\n    if (!(currentFolder instanceof FolderItem)) continue;\n    if (currentFolder.name.indexOf(\"Page_\") < 0) continue;\n    for (let j = 1; j <= currentFolder.numItems; j++) {\n      let currentComp = currentFolder.item(j);\n      if (!(currentComp instanceof CompItem)) continue;\n      if (currentComp.name === \"internal\") continue;\n      let greatest = 0;\n      forEachLayer(currentComp, (layer) => {\n        let layerOpacity = layer.property(\"Opacity\");\n        if (!(layerOpacity instanceof Property)) return;\n        let layerPos = layer.property(\"Position\");\n        if (!(layerPos instanceof Property)) return;\n        let layerScale = layer.property(\"Scale\");\n        if (!(layerScale instanceof Property)) return;\n        let greateastTime = 0;\n        for (let k = 1; k <= layerOpacity.numKeys; k++) {\n          if (layerOpacity.keyTime(k) > greateastTime)\n            greateastTime = layerOpacity.keyTime(k);\n        }\n        for (let k = 1; k <= layerPos.numKeys; k++) {\n          if (layerPos.keyTime(k) > greateastTime)\n            greateastTime = layerPos.keyTime(k);\n        }\n        for (let k = 1; k <= layerScale.numKeys; k++) {\n          if (layerScale.keyTime(k) > greateastTime)\n            greateastTime = layerScale.keyTime(k);\n        }\n        greatest = Math.max(greatest, greateastTime);\n      });\n      if (greatest > 0) currentComp.workAreaDuration = greatest;\n      else currentComp.workAreaDuration = 1;\n      app.project.renderQueue.items.add(currentComp);\n    }\n  }\n};\n\nexport const panLayer = () => {\n  app.beginUndoGroup(\"Pan Layer\");\n  let comp = app.project.activeItem;\n  if (!(comp instanceof CompItem)) return;\n  let curr = comp.selectedLayers[0];\n  if (!(curr instanceof AVLayer)) return;\n  let newNull = comp.layers.addNull();\n  let newNullPos = newNull.property(\"Position\");\n  let currPos = curr.property(\"Position\");\n  if (!(currPos instanceof Property)) return;\n  if (!(newNullPos instanceof Property)) return;\n  let oldPos = currPos.valueAtTime(0, true);\n  curr.parent = newNull;\n  newNullPos.setValueAtTime(0, [\n    1080 - (curr.width * (curr.scale.value[0] / 100)) / 2,\n    newNull.position.value[1],\n  ]);\n  newNullPos.setValueAtTime(6, [\n    (curr.width * (curr.scale.value[0] / 100)) / 2,\n    newNull.position.value[1],\n  ]);\n  newNullPos.setTemporalEaseAtKey(1, [slowFastSlow[0]], [slowFastSlow[1]]);\n  newNullPos.setTemporalEaseAtKey(2, [slowFastSlow[2]], [slowFastSlow[3]]);\n  app.endUndoGroup();\n};\n\nexport const getPanels = (): LayerObj[] => {\n  let comp = app.project.activeItem;\n  if (!(comp instanceof CompItem)) return [];\n  let layers = [];\n  for (let i = 1; i <= comp.numLayers; i++) {\n    let out = [];\n    for (let j = comp.numLayers; j > i; j--) {\n      out.push(\"up\");\n    }\n    let layerObj = {\n      name: comp.layer(i).name,\n      index: i,\n      count: 1,\n      scaleFactor: 1,\n      in: \"down\",\n      out: out,\n      prev: \"keep\",\n      darken: false,\n    };\n    layers.push(layerObj);\n  }\n  return layers;\n};\n\nexport const updateValues = () => {\n  app.beginUndoGroup(\"Update Values\");\n  alert(\"This will update all values in the comp to the current time\");\n  let comp = app.project.activeItem;\n  if (!(comp instanceof CompItem)) return;\n  let layers = [];\n  for (let i = 1; i <= comp.numLayers; i++) {\n    let layerObj = {\n      name: comp.layer(i).name,\n      index: i,\n      layer: comp.layer(i),\n    };\n    layers.push(layerObj);\n  }\n\n  const parentFolder = comp.parentFolder;\n  let pastCurrentComp = false;\n  for (let i = 1; i <= parentFolder.numItems; i++) {\n    if (pastCurrentComp) {\n      let currentComp = parentFolder.item(i);\n      if (!(currentComp instanceof CompItem)) continue;\n      for (let j = 1; j <= currentComp.numLayers; j++) {\n        let currentLayer = currentComp.layer(j);\n        for (let k = 0; k < layers.length; k++) {\n          if (layers[k].name !== currentLayer.name) continue;\n          const [currOpacity, currPos, currScale] = getLayerProps(currentLayer);\n          const [oldOpacity, oldPos, oldScale] = getLayerProps(layers[k].layer);\n          let parentLayer = layers[k].layer.parent;\n          let actualPosition = oldPos.valueAtTime(15, true);\n          if (parentLayer) {\n            var childPosition = layers[k].layer.transform.position.value;\n            var parentPosition = parentLayer.transform.position.value;\n            actualPosition = [\n              childPosition[0] + parentPosition[0],\n              childPosition[1] + parentPosition[1],\n            ];\n          }\n          const direction = getAnimDirection(currentLayer);\n          let currPosPrev = currPos.valueAtTime(2, true);\n          currPos.setValueAtTime(0, actualPosition);\n          currScale.setValueAtTime(0, oldScale.valueAtTime(15, false));\n          currOpacity.setValueAtTime(0, oldOpacity.valueAtTime(15, false));\n          if (direction === \"left\")\n            currPos.setValueAtTime(2, [currPosPrev[0], actualPosition[1]]);\n          if (direction === \"down\") {\n            currPos.setValueAtTime(2, [actualPosition[0], currPosPrev[1]]);\n          }\n        }\n      }\n      return;\n    }\n    if (parentFolder.item(i) == comp) pastCurrentComp = true;\n  }\n  app.endUndoGroup();\n};\n","// @include './lib/json2.js'\n\nimport { ns } from \"../shared/shared\";\n\nimport * as aeft from \"./aeft/aeft\";\n\n//@ts-ignore\nconst host = typeof $ !== \"undefined\" ? $ : window;\n\nswitch (BridgeTalk.appName as ApplicationName) {\n  case \"aftereffects\":\n  case \"aftereffectsbeta\":\n    host[ns] = aeft;\n    break;\n}\n\nexport type Scripts = typeof aeft\n\n// https://extendscript.docsforadobe.dev/interapplication-communication/bridgetalk-class.html?highlight=bridgetalk#appname\ntype ApplicationName =\n  | \"aftereffects\"\n  | \"aftereffectsbeta\"\n  | \"ame\"\n  | \"amebeta\"\n  | \"audition\"\n  | \"auditionbeta\"\n  | \"bridge\"\n  | \"bridgebeta\"\n  // | \"flash\"\n  | \"illustrator\"\n  | \"illustratorbeta\"\n  | \"indesign\"\n  | \"indesignbeta\"\n  // | \"indesignserver\"\n  | \"photoshop\"\n  | \"photoshopbeta\"\n  | \"premierepro\"\n  | \"premiereprobeta\";\n"],"names":["version","id","displayName","symlink","port","servePort","startingDebugPort","extensionManifestVersion","requiredRuntimeVersion","hosts","name","type","iconDarkNormal","iconNormal","iconDarkNormalRollOver","iconNormalRollOver","parameters","width","height","panels","mainPath","panelDisplayName","autoVisible","build","jsxBin","sourceMap","zxp","country","province","org","password","tsa","installModules","copyAssets","copyZipAssets","index","layer","scaleFactor","darken","layers","scaleFactorY","scaleFactorX","layerPos","layerOpacity","darkBGOpacity","darkBG","upOut","rightOut","app","currentCount","forEachLayer","_ret","newNullPos","out","count","prev","currOpacity","currPos","currScale","oldOpacity","oldPos","oldScale","host"],"mappings":";;AAGA;AACEA;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAAUC;AAAcV;AAAsB;AAC9CW;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AACAC;AAEAC;AAEIC;AACAV;AACAW;AACAC;AACAL;AACAC;AACF;AAEFK;AACEC;AACAC;;AAEFC;AACEC;AACAC;AACAC;AACAC;AACAC;AACAN;AACAD;;AAEFQ;AACAC;AACAC;AACF;;AChDA;;ACWA;;;;AAQE;AACE;AACA;;AAEA;AACA;;AAEEC;AACAC;;AAEA;;AAEAC;;AAEAC;;AAEFC;AACF;AACAA;AACE;AACE;AACF;AACA;AACE;AACF;AACA;AACF;AACA;AACF;AAEA;AACE;AACA;;;AAGA;AACEC;AACF;AACA;AACEC;AACF;;AAEA;AACF;AAgCA;AACE;AACA;AACA;AACA;AACF;AAEA;AACE;AACA;;;;AAKA;AACF;;AC5GA;;;AAUM;AACAC;AACF;AACE;;AAWAA;AACF;AACF;;AAKEC;AACAA;AACF;AACF;AAEA;;;;AAUMD;AAKF;;;AAGA;AACF;;AAEA;AACF;AAEA;;;;;;AAaE;;;AAGA;AACF;AAEA;;AASI;;AAUAA;AACF;AACEA;AAIAC;AACAA;AACF;AACF;;AC7GA;AAOA;;ACHA;;;;;AAYM;AACA;AACAC;;AAEEA;AACF;AACAC;AACF;AACF;;AAEA;AACF;AAEA;AAME;AACA;AACA;AACA;AAEA;AACA;AACA;;AAIA;;;;AAIA;;AAEA;;AAEA;AACAH;AACAA;AAEAC;AACAA;AACF;AAEA;AAME;AACA;AACA;AAEA;AACA;AACA;AAEA;AACAD;AACA;AAEA;AACEI;AACF;AACEC;AACF;;AAEA;AACAL;AACAA;AACF;;ACzFA;AAIE;AACA;;AAEA;AACF;;;;;;;;ACOA;AACEM;AACA;AACA;AACA;;;;;AAKA;AACE;;;;;AAYI;AACA;;AAEA;AACA;;;;AAQAT;AACF;AACAU;AACF;AACF;;AAEA;AACF;AAEA;AACE;;AAEE;;;AAGE;AACA;AACA;;AAEAC;AACE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACE;AAEF;AACA;AACE;AAEF;AACA;AACE;AAEF;;AAEF;AACA;;;;AA3BF;AAAgDC;AAAA;AAEG;AA6BrD;AACF;AAEA;AACEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGAI;AAIAA;AAIAA;AACAA;;AAEF;AAEA;AACE;AACA;;AAEA;;AAEE;AACEC;AACF;AACA;;AAEElB;AACAmB;AACAjB;AACA;AACAgB;AACAE;AACAjB;;AAEFC;AACF;AACA;AACF;AAEA;AACES;;AAEA;AACA;;AAEA;AACE;;AAEEb;AACAC;;AAEFG;AACF;AAEA;;AAEA;AACE;AACE;AACA;AACA;AACE;AACA;;AAEE;;AAAOiB;AAAaC;AAASC;;;AACtBC;AAAYC;AAAQC;;;AAG3B;AACE;;;AAMF;AACA;;AAEAJ;AACAC;AACAF;;;AAIEC;AACF;AACF;AACF;AACA;AACF;;AAEF;;AAEF;;;;;;;;;;;AClMA;AAEA;AACE;AACA;AACEK;AACA;AACJ;;AAIA"}